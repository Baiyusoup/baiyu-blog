---
title: 函数式编程
date: 2021-04-08
categories:
 - JavaScript
author: 青菜白玉汤
---

## 组合函数
用于组合合并函数，最后输出
```javascript
function compose(fns) {
  // 返回一个函数，方便存储
  return function(...args) {
    let start = fns.length - 1;
    let res = [...args];
    // 遍历函数列表
    while(start >= 0) {
      result = fns[start].apply(fns[start], result)
      start--;
    }
    return start;
  }
}
```

## 数组扁平化

使用ES6的flat
```javascript
function flatting(arr, num = 1) {
  return arr.flat(num)
}
```

使用ES6的reduce
```javascript
function flatting(arr) {
  return arr.reduce((acc, cur) => {
    if (Array.isArray(cur)) {
      acc.push(...flatting(cur))
    } else {
      acc.push(cur)
    }
    return acc
  }, [])
}
```

使用递归
```javascript
function flatting(arr) {
  let result = [];
  for(let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatting(arr[i]))
    } else {
      result.push(arr[i])
    }
  }
  return result;
}
```

## 图片懒加载

通过监听scroll事件
```javascript
const lazyLoad = function() {
  let num = 0
  let imgList = [...document.querySelectorAll('img')]
  let total = imgList.length
  return function() {
    const deleteIdx = []
    imgList.forEach((img, index) => {
      let rect = img.getBoundingClientRect()

      // 判断该图片是否出现在视图窗口内
      if (rect.top < window.innerHeight) {
        img.src = img.dataset.src
        deleteIdx.push(index)
        num += 1
      }
    })
    imgList = imgList.filter((img, idx) => !deleteIdx.contains(idx))
    if (num === total) {
      document.removeEventListener('scroll', lazyLoad)
    }
  }
}
```

使用IntersectionObserver
```javascript
const lazyLoad = function(imgs) {
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.intersectionRatio > 0) {
        entry.target.src = dataset.src
        observer.unobserve(entry.target)
      }
    })
  })
  imgs.forEach(img => observer.observe(img))
}
```

## 防抖
思路就是，建立一个定时器，如果在规定时间内没有触发事件，就执行，如果触发了事件，就将上一个定时器删掉，重新设置一个定时器

使用场景：监听滚动条、窗口尺寸变化、鼠标移动等

```javascript
const debounce = function(fn, ms = 0) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => fn.call(this, ...args), ms)
  }
}
```

## 节流
每隔一定的时间执行一次函数，降低函数执行的频度