---
title: js 函数
date: 2020-12-06
categories:
 - javascript
author: 青菜白玉汤
---

## 声明

```javascript
// 第一种
function foo () {}

// 第二种 函数表达式
const foo = function () {}
const foo = function bar() {}

// 第三种 箭头函数
const foo = () => {}

// 第四种
const foo = new Function()
```

​	在JavaScript里，声明函数的方式共有以上四种，他们的作用都是一样的，但是js引擎在解析第一种和另外几种的时候却有些差异。

js引擎在解析脚本的时候，首先会寻找函数声明，即第一种，然后将其提升到源码树的顶部，这样就算在函数声明之前也能成功调用。但是另外几种是函数表达式，是赋值行为，因此知道当解析到那行代码时，函数才会被添加到执行上下文，因此无法在那之前调用该函数

## arguments

```javascript
function foo (a, b){
    arguments[0] === a // true
}
arguments = {
    0: a,
    1: b
    ...
    length； 2
    caller: Function
}
```

arguments是一个类数组对象，保存着命名参数（a，b）的值，需要注意的是，即便我们不声明形参，只要我们调用的时候，放上了实参，就可以通过arguments获取到。

arguments反映着命名参数的变化，但是它保存命名参数的值的地址和命名参数的地址是不一样的，然而改变arguments的值会反映到命名参数上，但是命名参数的改变却不会影响到arguments的值，具体如下

```javascript
function foo(a, b) {
    arguments[0] = 4 // a  => 4
    b = 3			// arguments[1] => 2
}
foo(1, 2)

function foo2() {
    arguments[0] // 1
    arguments[1] // 2
}
foo2(1, 2)
```

arguments对象的caller属性指向该函数本身，在严格模式下为undefined

## new.target

该属性指向函数的构造函数，如果函数使用了new关键词，那么该属性指向该函数的构造函数。平常情况下为undefined，可用来判断函数是不是被作为构造函数使用

## caller

指向调用该函数的函数

## apply/call

在调用函数，指定函数的this指向。两者的作用都是一样的，区别在于传递参数的方式，前者传递的参数必须为数组，后者传递参数必须逐个传递

```javascript
const foo = function (a, b) {}
foo.apply(window, [1, 2])
foo.call(window, 1, 2)
```



## this

指向调用该函数的上下文对象，在箭头函数里，指向的是定义该箭头函数的上下问对象

## prototype

原型

## 立即调用函数

```javascript
(function (a, b) {})(1, 2)

(function (a, b) {} (1, 2))
```

立即调用函数会被解析成函数表达式，因此在运行完后，占用的内存会立即被销毁掉，原因在于执行完后，没有变量引用这个函数

## 闭包

闭包是指那些引用了其他函数作用域变量的函数。

```javascript
function foo () {
    let b = 2
    return function () {
        b += 1
    }
}
```

如果内部函数不是箭头函数定义的，那么this的指向将会指向运行时执行函数的上下文对象。

可以利用闭包实现私有变量