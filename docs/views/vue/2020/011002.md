---
title: Vuex
date: 2020-10-01
categories:
 - javaScript
author: 青菜白玉汤
tags:
 - vue
 - vuex
---

## 核心概念


`state`

```javascript
this.$store.state
this.$store.commit()

computed: mapState(['xxx', ...]); 当一个组件要获取多个state时，声明计算属性会变得重复和冗余，mapState生成计算属性
computed: {
   localComputed() {}, // 本地的计算属性
  ...mapState(['xxx', ...])
}
```

`getter`

```javascript
// 需要从store中的state中派生出一些状态时，最好使用使用getters而不是mapState
getters: {
    toDo: (state, getters) => {
    },
    getDo: state => id => {
    }
}

// getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的
this.$store.getters.todo
// getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果
this$store.getters.getDo(1)

mapGetters
```

### Mutations

```javascript
this.$store.commit()
// 在需要在state对象上添加新属性时，应该使用Vue.set() 或者 state.obj = { ...state.obj, newProp: 23 }
mapMutations
```

### Actions

```javascript
actions: {
    increment (context, payload) {
        // const { commit, state, getters } = context
        context.commit()
        // commit(types.TODO)
    }
}
this.$store.dispatch()
mapActions  // 和methods映射

// 使用Promis 或者async/awit 提醒actions的动作已结束
```

### Module

```javascript
const moduleA = {
    getters: {
    sumWithRootCount (state, getters, rootState) {
      return state.count + rootState.count
    }
  },
  actions: {
      // rootState 根节点
    incrementIfOddOnRootSum ({ state, commit, rootState }) {
      if ((state.count + rootState.count) % 2 === 1) {
        commit('increment')
      }
    }
  }
}

// 使用了命名空间namespace: true
const moduleA = {
    namespace: true,
    getters: {
    sumWithRootCount (state, getters, rootState, rootGetters) {
      return state.count + rootState.count
    }
  },
  actions: {
      // rootState 根节点
    incrementIfOddOnRootSum ({ dispatch, commit, getters, rootGetters }) {
        // 全局空间内
      dispatch('someOtherAction', null, { root: true })
      commit('someMutation', null, { root: true })
        // 分发或提交到其他命名空间
       dispatch('moduleB/someOtherAction', null, { root: true })
       commit('moduleB/someMutation', null, { root: true })
    }
  },
  someGlobleAction: {
      // 在命名空间的模块注册全局的action
      root: true,
      handler(namespacedContext, payload) { ... } 
  }
}

    ...mapState('some/nested/module', [])
    ...mapMutations('some/nested/module', [])
	...mapGetters('some/nested/module', [])
	...mapActions('some/nested/module', [])
```

```javascript
// 创建某个命名空间的模块
import { createNamespacedHelpers } from 'vuex'
const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')
export default {
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
```

#### 模块动态注册

构建大型 SPA 应用时，代码分割和懒加载是比较常用的优化手段，在 Vue 生态下，使用 vue-router 很容易实现组件的懒加载。

但应用里除了组件，还有庞大的业务逻辑，这部分如何分割和懒加载比较合适呢？

使用 Vuex 管理状态的话，其提供了方法 `registerModule` 用于动态注册Module。

因此某个页面独有的业务逻辑和状态管理，在初始化全局 store 的时候可以不用引入，之后在该页面路由组件中再引入和注册 Vuex 模块。

```javascript
// 注册模块 `myModule`
this.$store.registerModule('myModule', {
  // ...
})
// 注册嵌套模块 `nested/myModule`
this.$store.registerModule(['nested', 'myModule'], {
  // ...
})
// 卸载动态模块
this.$store.unregisterModule(moduleName)
```

[实践](https://hikerpig.github.io/2018/07/03/2018-07-03-Vuex-Dynamic-Module-Hints/)



### 插件

```javascript
const myPlugin = store => {
  // 当 store 初始化后调用
  store.subscribe((mutation, state) => {
    // 每次 mutation 之后调用
    // mutation 的格式为 { type, payload }
  })
}

const store = new Vuex.Store({
  // ...
  plugins: [myPlugin]
})
```



### Store实例方法

1. subscribe 订阅store的mutation
2. subscribeAction 订阅store的Action
3. ...